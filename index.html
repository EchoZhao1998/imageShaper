<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shape Cropper</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin-top: 10px;
      width: 90vw;
      max-width: 420px;
      height: auto;
      aspect-ratio: 1 / 1;
      touch-action: none;
    }
  </style>
</head>
<body>

<h1>Shape Cropper</h1>

<input type="file" id="upload" accept="image/*" />

<label for="shapeSelect">Select shape:</label>
<select id="shapeSelect">
  <option value="circle">Circle</option>
  <option value="rounded-rect">Rounded Rectangle</option>
</select>

<canvas id="canvas" width="400" height="400"></canvas>

<!-- Export button -->
<button id="exportBtn">Export PNG </button>

<script>
  const upload = document.getElementById("upload");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    redraw();
  }

  window.addEventListener("resize", resizeCanvas);

  const shapeSelect = document.getElementById("shapeSelect");
  const exportBtn = document.getElementById("exportBtn");

  let img = null;

  // image position
  let imgX = 0;
  let imgY = 0;

  // image draw size (IMPORTANT: global)
  let drawWidth = 0;
  let drawHeight = 0;

  // dragging state (Pointer Events)
  let isDragging = false;
  let activePointerId = null;
  let startX = 0;
  let startY = 0;

  // shapes
  let currentShape = "circle"; // default shape

  resizeCanvas();

  // e.target.value to "circle" or "rounded-rect"
  // Updates your single source of truth: currentShape
  // Calls redraw() to re-render with the new mask
  shapeSelect.addEventListener("change", (e) => {
    currentShape = e.target.value;
    redraw();
  });

  canvas.addEventListener("pointerdown", (e) => {
    if (!img || isDragging) return;

    isDragging = true;
    activePointerId = e.pointerId;

    startX = e.offsetX;
    startY = e.offsetY;

    canvas.setPointerCapture(activePointerId);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!isDragging || e.pointerId !== activePointerId || !img) return;

    const dx = e.offsetX - startX;
    const dy = e.offsetY - startY;

    imgX += dx;
    imgY += dy;

    startX = e.offsetX;
    startY = e.offsetY;

    redraw();
  });

  function endPointerDrag(e) {
    if (e.pointerId !== activePointerId) return;

    isDragging = false;
    activePointerId = null;

    canvas.releasePointerCapture(e.pointerId);
  }

  canvas.addEventListener("pointerup", endPointerDrag);
  canvas.addEventListener("pointercancel", endPointerDrag);

  function drawRoundedRectPath(ctxRef, x, y, width, height, radius) {
    const r = Math.min(radius, width / 2, height / 2);

    ctxRef.moveTo(x + r, y);
    ctxRef.lineTo(x + width - r, y);
    ctxRef.quadraticCurveTo(x + width, y, x + width, y + r);

    ctxRef.lineTo(x + width, y + height - r);
    ctxRef.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
    ctxRef.lineTo(x + r, y + height);
    ctxRef.quadraticCurveTo(x, y + height, x, y + height - r);

    ctxRef.lineTo(x, y + r);
    ctxRef.quadraticCurveTo(x, y, x + r, y);
  }

  function redraw() {
    if (!img) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();

    // circle mask
    ctx.beginPath();

    if (currentShape === "circle") {
    ctx.arc(
        canvas.width / 2,
        canvas.height / 2,
        canvas.width / 2,
        0,
        Math.PI * 2
        );
    }


    if (currentShape === "rounded-rect") {
        const padding = 0;
        const radius = 40;

        drawRoundedRectPath(
          ctx,
          padding,
          padding,
          canvas.width - padding * 2,
          canvas.height - padding * 2,
          radius
        );
    }

    ctx.clip();
    ctx.drawImage(img, imgX, imgY, drawWidth, drawHeight);
    ctx.restore();
    }

    // Export button functionality
    function exportTransparentPNG() {
        if (!img) return;

        // Create an offscreen canvas (same size as main canvas)
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = canvas.width;
        exportCanvas.height = canvas.height;

        const exportCtx = exportCanvas.getContext("2d");
        // IMPORTANT:
        // Do NOT fill background.
        // Canvas defaults to transparent.

        exportCtx.save();
        exportCtx.beginPath();

        if (currentShape === "circle") {
            exportCtx.arc(
            exportCanvas.width / 2,
            exportCanvas.height / 2,
            exportCanvas.width / 2,
            0,
            Math.PI * 2
        );
        }

        if (currentShape === "rounded-rect") {
            const padding = 0;
            const radius = 40;

            // Reuse same geometry logic
            drawRoundedRectPath(
              exportCtx,
              padding,
              padding,
              exportCanvas.width - padding * 2,
              exportCanvas.height - padding * 2,
              radius
            );
        }

        exportCtx.clip();

        // Draw the image using the SAME transform values
        exportCtx.drawImage(img, imgX, imgY, drawWidth, drawHeight);

        exportCtx.restore();

        // Convert to PNG
        const pngURL = exportCanvas.toDataURL("image/png");

        // Trigger download
        const link = document.createElement("a");
        link.href = pngURL;
        link.download = "cropped-image.png";
        link.click();
      }

  upload.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;

    img = new Image();

    img.onload = () => {
      resizeCanvas();

      const canvasRatio = canvas.width / canvas.height;
      const imgRatio = img.width / img.height;

      if (imgRatio > canvasRatio) {
        // image is wider
        drawHeight = canvas.height;
        drawWidth = img.width * (canvas.height / img.height);
        imgX = -(drawWidth - canvas.width) / 2;
        imgY = 0;
      } else {
        // image is taller
        drawWidth = canvas.width;
        drawHeight = img.height * (canvas.width / img.width);
        imgX = 0;
        imgY = -(drawHeight - canvas.height) / 2;
      }

      redraw();
    };

    img.src = URL.createObjectURL(file);
  });

    exportBtn.addEventListener("click", exportTransparentPNG);
</script>

</body>
</html>
